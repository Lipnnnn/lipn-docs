# 基础面试题

## ❓Vue 的响应式原理

> **总体思路：**
>
> 1. Vue 是怎么**追踪依赖**的（数据和视图的绑定过程）
> 2. 数据变化后，Vue 是怎么**通知更新**的
> 3. Vue2 和 Vue3 的实现机制有什么差异

### 🙋 回答：

### Vue2 响应式原理（Object.defineProperty）

Vue2 在初始化数据时，会使用 `Object.defineProperty` 对对象的每个属性进行劫持（getter/setter）。

- **依赖收集**：当模板里访问数据时，会触发 getter，将当前的 watcher（渲染函数或计算属性）收集起来。
- **派发更新**：当数据变化时，setter 会触发通知，调用 watcher 的 update 方法，重新执行渲染或计算。

### ⚠️ 局限性：

- 不能监听对象属性的新增/删除（需使用 `Vue.set`、`Vue.delete`）。
- 不能检测数组索引的变更和 `length` 修改（只能通过 `splice` 等方法触发更新）。

### 📌 代码示例：

```js
// Vue2 简化版
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      // 依赖收集
      return val;
    },
    set(newVal) {
      val = newVal;
      // 派发更新
      update();
    },
  });
}
```

### Vue3 响应式原理(Proxy + Reflect)：

Vue3 使用 `Proxy` 替代 Object.defineProperty，直接代理整个对象。

- **依赖收集**：get 时调用 `track` 收集依赖。
- **派发更新**：set 时调用 `trigger` 通知副作用函数重新执行。

### ✅ 优势：

- 可以监听对象属性的新增/删除。
- 可以检测数组索引的变更和 length 修改。
- 性能更好，不需要递归遍历所有属性。

### 📌 代码示例：

```js
// Vue3 简化版
const handler = {
  get(target, key, receiver) {
    track(target, key);
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver);
    trigger(target, key);
    return result;
  },
};
const proxy = new Proxy(obj, handler);
```

**总结一句话（面试官爱听）：**

> **Vue 的响应式核心是 依赖收集 + 派发更新。Vue2 基于 Object.defineProperty，存在一些缺陷；Vue3 基于 Proxy，更强大更灵活。**

## ❓ 浏览器从输入 url 到页面渲染的过程

> **总体思路：**
>
> 1. 输入 URL 后，浏览器解析 URL。
> 2. 缓存检查。
> 3. DNS 查询。
> 4. 建立 TCP 连接。
> 5. 发送 HTTP 请求。
> 6. 服务器处理请求并返回响应。
> 7. 浏览器接收并处理响应。
> 8. 页面渲染与显示。

### 🙋 回答：

### 1. URL 解析
浏览器将 URL 分解为不同的部分：
- 协议（如 http/https）
- 域名
- 端口
- 路径（如 /index.html）
- 查询参数
- 锚点（如 #section-1）

### 2. 缓存检查
浏览器检查本地缓存，根据缓存策略判断资源是否有效：
- 如果缓存有效，直接使用缓存资源，避免网络请求
- 如果缓存无效或不存在，继续后续流程

### 3. DNS 查询
浏览器通过域名查找服务器 IP 地址：
1. 检查本地 DNS 缓存（操作系统维护）
2. 如果缓存中没有，向本地 DNS 服务器发送查询请求
3. 本地 DNS 服务器进行递归查询，直到找到对应 IP 地址

## 4. 建立连接
根据协议建立网络连接：

### TCP 连接（三次握手）
1. 浏览器发送 SYN 数据包（请求建立连接）
2. 服务器返回 SYN + ACK 数据包（同意建立连接）
3. 浏览器发送 ACK 数据包（确认建立连接）

### HTTPS 额外步骤
- 在 TCP 连接后进行 SSL/TLS 握手
- 证书验证、密钥交换
- 建立安全加密通道

## 5. 发送请求
建立连接后，浏览器发送 HTTP 请求：
- **请求行**：请求方法（GET/POST）、URI、HTTP 版本
- **请求头**：主机名、内容类型、语言等信息
- **请求体**：POST 请求时包含的数据

## 6. 服务器处理
服务器处理请求并返回响应：
- 读取文件内容或执行服务器端脚本（PHP/Python 等）
- 构建 HTTP 响应：
  - **响应行**：HTTP 版本、状态码（200/404 等）
  - **响应头**：内容类型、内容长度、缓存策略等
  - **响应体**：HTML 代码、图片数据、JSON 数据等

## 7. 处理响应
浏览器处理服务器响应：

### 根据状态码处理
- 200 OK：处理成功响应
- 404 Not Found：处理资源不存在情况

### 根据内容类型处理
- `text/html`：解析 HTML，构建 DOM 树
- `image/jpeg`：解码并显示图片
- `application/json`：传递给 JS 代码处理

### 资源加载
- 解析 HTML 时遇到外部资源（CSS/JS/图片）
- 暂停 HTML 解析，发起新请求获取资源
- 获取完成后继续解析

## 8. 页面渲染
完成资源加载后进行页面渲染：

### 构建渲染树
- 结合 DOM 树和 CSS 样式规则
- 包含所有可见元素的样式和布局信息

### 布局和绘制
1. **布局**：确定元素位置和大小
2. **绘制**：将内容绘制到屏幕上

### 动态更新
- JavaScript 可能修改 DOM 或样式
- 触发重新渲染（重新计算渲染树、布局和绘制）
- 更新页面显示内容

1. 浏览器将 URL 分解为不同的部分，包括协议、域名、端口、路径（如/index.html）、查询参数和锚点（如#section-1）。
2. 浏览器会检查本地缓存，看是否已经有请求资源的副本，它会根据缓存策略（如 Cache-Control 和 Expires 等 HTTP 头信息）来判断缓存是否有效。如果缓存中存在有效资源，浏览器可以直接使用缓存中的资源，从而避免了一次网络请求，提高了访问速度。
3. 如果缓存中没有可用资源，或者缓存已过期，浏览器需要通过域名来找到对应的服务器 IP 地址，这就需要进行 DNS 查询。浏览器首先会检查本地的 DNS 缓存（操作系统会维护一个 DNS 缓存），看是否已经有域名对应的 IP 地址。如果本地 DNS 缓存中没有，浏览器会向本地 DNS 服务器发送查询请求，如果还是没有，本地 DNS 服务器会向其他 DNS 服务器进行递归查询，直到找到域名对应的 IP 地址。
4. 在得到服务器的 IP 地址之后，浏览器会根据 URL 中的协议（如 http 或 https）与服务器建立 TCP 连接。对于 http 协议，浏览器会向服务器的 80 端口发起连接请求；对于 https 协议，会向 443 端口发起连接请求。这个过程包括三次握手：首先浏览器发送一个带有 SYN 标志的 TCP 数据包给服务器，表示请求建立连接；服务器收到后，会返回一个带有 SYN 和 ACK 标志的数据包，表示同意建立连接并确认收到浏览器的请求；最后，浏览器再发送一个带有 ACK 标志的数据包，完成三次握手，此时 TCP 连接建立成功。对于 https 协议，在建立 TCP 连接之后，还会进行 SSL/TLS 握手，以建立安全的加密通道。这个过程涉及到证书验证、密钥交换等步骤，用于确保通信的安全性。
5. TCP 连接建立后，浏览器会按照 HTTP 协议向服务器发送请求，请求包括请求行（包含请求方法，如 GET、POST 等，请求的 URI 和 HTTP 版本），请求头（包含各种信息，如主机名称、接受的内容类型、语言等）和请求体（如果是 POST 请求有请求体）。
6. 服务器收到浏览器的请求后，会根据请求的内容进行处理。如果请求的是一个网页文件，服务器可能会读取文件内容，进行一些动态处理（如执行服务器端脚本语言，如 PHP、Python 等），然后将处理后的结果构建成 HTTP 响应返回给浏览器。响应包括响应行（包含 HTTP 版本、响应状态码，如 200 OK、404 Not Found 等），响应头（包含内容类型、内容长度、缓存策略等信息）和响应体（包含实际的内容，如网页的 HTML 代码、图片数据、JSON 数据等）。
7. 浏览器接收到服务器的响应后，首先会检查响应状态码。如果状态码是 200 OK 等表示成功的状态码，浏览器会根据响应头中的内容类型信息来处理响应体。如果内容类型是 text/html，浏览器会开始解析 HTML 代码，构建 DOM 树，在解析 HTML 的过程中，遇到外部资源引用（如'<'link>标签引用 CSS 文件，'<'script>标签引用 JavaScript 文件，'<'img>标签引用图片等），浏览器会暂停 HTML 解析，发起新的请求来获取这些外部资源，然后继续解析。如果类型是 image/jpeg 等图片类型，浏览器会对图片数据进行解密并显示。如果是 application/json 等数据类型，浏览器可能会将数据传递给 JS 代码进行进一步处理。
8. 在浏览器构建好 DOM 树，并且获取并处理好所有外部资源（如 CSS 文件、JavaScript 文件等）后，就会开始进行页面渲染。浏览器会根据 DOM 树和 CSS 样式规则构建渲染树。渲染树包含了页面中所有可见元素的样式和布局信息。然后，浏览器会根据渲染树进行布局，确定每个元素在页面中的位置和大小，并最终将页面内容绘制到屏幕上。在这个过程中，JavaScript 代码可能会对 DOM 树和页面布局进行动态修改，导致浏览器重新进行渲染和绘制。例如，通过 JS 修改了一个元素的样式或者添加了新的元素，浏览器会重新计算渲染树、重新布局和绘制，以更新页面显示。

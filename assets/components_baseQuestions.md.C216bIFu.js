import{_ as s,c as a,o as l,ae as e}from"./chunks/framework.CIso6Qi3.js";const c=JSON.parse('{"title":"基础面试题","description":"","frontmatter":{},"headers":[],"relativePath":"components/baseQuestions.md","filePath":"components/baseQuestions.md"}'),t={name:"components/baseQuestions.md"};function n(h,i,r,p,k,o){return l(),a("div",null,[...i[0]||(i[0]=[e(`<h1 id="基础面试题" tabindex="-1">基础面试题 <a class="header-anchor" href="#基础面试题" aria-label="Permalink to &quot;基础面试题&quot;">​</a></h1><h2 id="❓vue-的响应式原理" tabindex="-1">❓Vue 的响应式原理 <a class="header-anchor" href="#❓vue-的响应式原理" aria-label="Permalink to &quot;❓Vue 的响应式原理&quot;">​</a></h2><blockquote><p><strong>总体思路：</strong></p><ol><li>Vue 是怎么<strong>追踪依赖</strong>的（数据和视图的绑定过程）</li><li>数据变化后，Vue 是怎么<strong>通知更新</strong>的</li><li>Vue2 和 Vue3 的实现机制有什么差异</li></ol></blockquote><h3 id="🙋-回答" tabindex="-1">🙋 回答： <a class="header-anchor" href="#🙋-回答" aria-label="Permalink to &quot;🙋 回答：&quot;">​</a></h3><h3 id="vue2-响应式原理-object-defineproperty" tabindex="-1">Vue2 响应式原理（Object.defineProperty） <a class="header-anchor" href="#vue2-响应式原理-object-defineproperty" aria-label="Permalink to &quot;Vue2 响应式原理（Object.defineProperty）&quot;">​</a></h3><p>Vue2 在初始化数据时，会使用 <code>Object.defineProperty</code> 对对象的每个属性进行劫持（getter/setter）。</p><ul><li><strong>依赖收集</strong>：当模板里访问数据时，会触发 getter，将当前的 watcher（渲染函数或计算属性）收集起来。</li><li><strong>派发更新</strong>：当数据变化时，setter 会触发通知，调用 watcher 的 update 方法，重新执行渲染或计算。</li></ul><h3 id="⚠️-局限性" tabindex="-1">⚠️ 局限性： <a class="header-anchor" href="#⚠️-局限性" aria-label="Permalink to &quot;⚠️ 局限性：&quot;">​</a></h3><ul><li>不能监听对象属性的新增/删除（需使用 <code>Vue.set</code>、<code>Vue.delete</code>）。</li><li>不能检测数组索引的变更和 <code>length</code> 修改（只能通过 <code>splice</code> 等方法触发更新）。</li></ul><h3 id="📌-代码示例" tabindex="-1">📌 代码示例： <a class="header-anchor" href="#📌-代码示例" aria-label="Permalink to &quot;📌 代码示例：&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue2 简化版</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineReactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, key, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 依赖收集</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVal;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 派发更新</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="vue3-响应式原理-proxy-reflect" tabindex="-1">Vue3 响应式原理(Proxy + Reflect)： <a class="header-anchor" href="#vue3-响应式原理-proxy-reflect" aria-label="Permalink to &quot;Vue3 响应式原理(Proxy + Reflect)：&quot;">​</a></h3><p>Vue3 使用 <code>Proxy</code> 替代 Object.defineProperty，直接代理整个对象。</p><ul><li><strong>依赖收集</strong>：get 时调用 <code>track</code> 收集依赖。</li><li><strong>派发更新</strong>：set 时调用 <code>trigger</code> 通知副作用函数重新执行。</li></ul><h3 id="✅-优势" tabindex="-1">✅ 优势： <a class="header-anchor" href="#✅-优势" aria-label="Permalink to &quot;✅ 优势：&quot;">​</a></h3><ul><li>可以监听对象属性的新增/删除。</li><li>可以检测数组索引的变更和 length 修改。</li><li>性能更好，不需要递归遍历所有属性。</li></ul><h3 id="📌-代码示例-1" tabindex="-1">📌 代码示例： <a class="header-anchor" href="#📌-代码示例-1" aria-label="Permalink to &quot;📌 代码示例：&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue3 简化版</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">receiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    track</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, key, receiver);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">receiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, key, value, receiver);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    trigger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, handler);</span></span></code></pre></div><p><strong>总结一句话（面试官爱听）：</strong></p><blockquote><p><strong>Vue 的响应式核心是 依赖收集 + 派发更新。Vue2 基于 Object.defineProperty，存在一些缺陷；Vue3 基于 Proxy，更强大更灵活。</strong></p></blockquote><h2 id="❓-浏览器从输入-url-到页面渲染的过程" tabindex="-1">❓ 浏览器从输入 url 到页面渲染的过程 <a class="header-anchor" href="#❓-浏览器从输入-url-到页面渲染的过程" aria-label="Permalink to &quot;❓ 浏览器从输入 url 到页面渲染的过程&quot;">​</a></h2><blockquote><p><strong>总体思路：</strong></p><ol><li>输入 URL 后，浏览器解析 URL。</li><li>缓存检查。</li><li>DNS 查询。</li><li>建立 TCP 连接。</li><li>发送 HTTP 请求。</li><li>服务器处理请求并返回响应。</li><li>浏览器接收并处理响应。</li><li>页面渲染与显示。</li></ol></blockquote><h3 id="🙋-回答-1" tabindex="-1">🙋 回答： <a class="header-anchor" href="#🙋-回答-1" aria-label="Permalink to &quot;🙋 回答：&quot;">​</a></h3><h3 id="_1-url-解析" tabindex="-1">1. URL 解析 <a class="header-anchor" href="#_1-url-解析" aria-label="Permalink to &quot;1. URL 解析&quot;">​</a></h3><p>浏览器将 URL 分解为不同的部分：</p><ul><li>协议（如 http/https）</li><li>域名</li><li>端口</li><li>路径（如 /index.html）</li><li>查询参数</li><li>锚点（如 #section-1）</li></ul><h3 id="_2-缓存检查" tabindex="-1">2. 缓存检查 <a class="header-anchor" href="#_2-缓存检查" aria-label="Permalink to &quot;2. 缓存检查&quot;">​</a></h3><p>浏览器检查本地缓存，根据缓存策略判断资源是否有效：</p><ul><li>如果缓存有效，直接使用缓存资源，避免网络请求</li><li>如果缓存无效或不存在，继续后续流程</li></ul><h3 id="_3-dns-查询" tabindex="-1">3. DNS 查询 <a class="header-anchor" href="#_3-dns-查询" aria-label="Permalink to &quot;3. DNS 查询&quot;">​</a></h3><p>浏览器通过域名查找服务器 IP 地址：</p><ol><li>检查本地 DNS 缓存（操作系统维护）</li><li>如果缓存中没有，向本地 DNS 服务器发送查询请求</li><li>本地 DNS 服务器进行递归查询，直到找到对应 IP 地址</li></ol><h2 id="_4-建立连接" tabindex="-1">4. 建立连接 <a class="header-anchor" href="#_4-建立连接" aria-label="Permalink to &quot;4. 建立连接&quot;">​</a></h2><p>根据协议建立网络连接：</p><h3 id="tcp-连接-三次握手" tabindex="-1">TCP 连接（三次握手） <a class="header-anchor" href="#tcp-连接-三次握手" aria-label="Permalink to &quot;TCP 连接（三次握手）&quot;">​</a></h3><ol><li>浏览器发送 SYN 数据包（请求建立连接）</li><li>服务器返回 SYN + ACK 数据包（同意建立连接）</li><li>浏览器发送 ACK 数据包（确认建立连接）</li></ol><h3 id="https-额外步骤" tabindex="-1">HTTPS 额外步骤 <a class="header-anchor" href="#https-额外步骤" aria-label="Permalink to &quot;HTTPS 额外步骤&quot;">​</a></h3><ul><li>在 TCP 连接后进行 SSL/TLS 握手</li><li>证书验证、密钥交换</li><li>建立安全加密通道</li></ul><h2 id="_5-发送请求" tabindex="-1">5. 发送请求 <a class="header-anchor" href="#_5-发送请求" aria-label="Permalink to &quot;5. 发送请求&quot;">​</a></h2><p>建立连接后，浏览器发送 HTTP 请求：</p><ul><li><strong>请求行</strong>：请求方法（GET/POST）、URI、HTTP 版本</li><li><strong>请求头</strong>：主机名、内容类型、语言等信息</li><li><strong>请求体</strong>：POST 请求时包含的数据</li></ul><h2 id="_6-服务器处理" tabindex="-1">6. 服务器处理 <a class="header-anchor" href="#_6-服务器处理" aria-label="Permalink to &quot;6. 服务器处理&quot;">​</a></h2><p>服务器处理请求并返回响应：</p><ul><li>读取文件内容或执行服务器端脚本（PHP/Python 等）</li><li>构建 HTTP 响应： <ul><li><strong>响应行</strong>：HTTP 版本、状态码（200/404 等）</li><li><strong>响应头</strong>：内容类型、内容长度、缓存策略等</li><li><strong>响应体</strong>：HTML 代码、图片数据、JSON 数据等</li></ul></li></ul><h2 id="_7-处理响应" tabindex="-1">7. 处理响应 <a class="header-anchor" href="#_7-处理响应" aria-label="Permalink to &quot;7. 处理响应&quot;">​</a></h2><p>浏览器处理服务器响应：</p><h3 id="根据状态码处理" tabindex="-1">根据状态码处理 <a class="header-anchor" href="#根据状态码处理" aria-label="Permalink to &quot;根据状态码处理&quot;">​</a></h3><ul><li>200 OK：处理成功响应</li><li>404 Not Found：处理资源不存在情况</li></ul><h3 id="根据内容类型处理" tabindex="-1">根据内容类型处理 <a class="header-anchor" href="#根据内容类型处理" aria-label="Permalink to &quot;根据内容类型处理&quot;">​</a></h3><ul><li><code>text/html</code>：解析 HTML，构建 DOM 树</li><li><code>image/jpeg</code>：解码并显示图片</li><li><code>application/json</code>：传递给 JS 代码处理</li></ul><h3 id="资源加载" tabindex="-1">资源加载 <a class="header-anchor" href="#资源加载" aria-label="Permalink to &quot;资源加载&quot;">​</a></h3><ul><li>解析 HTML 时遇到外部资源（CSS/JS/图片）</li><li>暂停 HTML 解析，发起新请求获取资源</li><li>获取完成后继续解析</li></ul><h2 id="_8-页面渲染" tabindex="-1">8. 页面渲染 <a class="header-anchor" href="#_8-页面渲染" aria-label="Permalink to &quot;8. 页面渲染&quot;">​</a></h2><p>完成资源加载后进行页面渲染：</p><h3 id="构建渲染树" tabindex="-1">构建渲染树 <a class="header-anchor" href="#构建渲染树" aria-label="Permalink to &quot;构建渲染树&quot;">​</a></h3><ul><li>结合 DOM 树和 CSS 样式规则</li><li>包含所有可见元素的样式和布局信息</li></ul><h3 id="布局和绘制" tabindex="-1">布局和绘制 <a class="header-anchor" href="#布局和绘制" aria-label="Permalink to &quot;布局和绘制&quot;">​</a></h3><ol><li><strong>布局</strong>：确定元素位置和大小</li><li><strong>绘制</strong>：将内容绘制到屏幕上</li></ol><h3 id="动态更新" tabindex="-1">动态更新 <a class="header-anchor" href="#动态更新" aria-label="Permalink to &quot;动态更新&quot;">​</a></h3><ul><li>JavaScript 可能修改 DOM 或样式</li><li>触发重新渲染（重新计算渲染树、布局和绘制）</li><li>更新页面显示内容</li></ul><ol><li>浏览器将 URL 分解为不同的部分，包括协议、域名、端口、路径（如/index.html）、查询参数和锚点（如#section-1）。</li><li>浏览器会检查本地缓存，看是否已经有请求资源的副本，它会根据缓存策略（如 Cache-Control 和 Expires 等 HTTP 头信息）来判断缓存是否有效。如果缓存中存在有效资源，浏览器可以直接使用缓存中的资源，从而避免了一次网络请求，提高了访问速度。</li><li>如果缓存中没有可用资源，或者缓存已过期，浏览器需要通过域名来找到对应的服务器 IP 地址，这就需要进行 DNS 查询。浏览器首先会检查本地的 DNS 缓存（操作系统会维护一个 DNS 缓存），看是否已经有域名对应的 IP 地址。如果本地 DNS 缓存中没有，浏览器会向本地 DNS 服务器发送查询请求，如果还是没有，本地 DNS 服务器会向其他 DNS 服务器进行递归查询，直到找到域名对应的 IP 地址。</li><li>在得到服务器的 IP 地址之后，浏览器会根据 URL 中的协议（如 http 或 https）与服务器建立 TCP 连接。对于 http 协议，浏览器会向服务器的 80 端口发起连接请求；对于 https 协议，会向 443 端口发起连接请求。这个过程包括三次握手：首先浏览器发送一个带有 SYN 标志的 TCP 数据包给服务器，表示请求建立连接；服务器收到后，会返回一个带有 SYN 和 ACK 标志的数据包，表示同意建立连接并确认收到浏览器的请求；最后，浏览器再发送一个带有 ACK 标志的数据包，完成三次握手，此时 TCP 连接建立成功。对于 https 协议，在建立 TCP 连接之后，还会进行 SSL/TLS 握手，以建立安全的加密通道。这个过程涉及到证书验证、密钥交换等步骤，用于确保通信的安全性。</li><li>TCP 连接建立后，浏览器会按照 HTTP 协议向服务器发送请求，请求包括请求行（包含请求方法，如 GET、POST 等，请求的 URI 和 HTTP 版本），请求头（包含各种信息，如主机名称、接受的内容类型、语言等）和请求体（如果是 POST 请求有请求体）。</li><li>服务器收到浏览器的请求后，会根据请求的内容进行处理。如果请求的是一个网页文件，服务器可能会读取文件内容，进行一些动态处理（如执行服务器端脚本语言，如 PHP、Python 等），然后将处理后的结果构建成 HTTP 响应返回给浏览器。响应包括响应行（包含 HTTP 版本、响应状态码，如 200 OK、404 Not Found 等），响应头（包含内容类型、内容长度、缓存策略等信息）和响应体（包含实际的内容，如网页的 HTML 代码、图片数据、JSON 数据等）。</li><li>浏览器接收到服务器的响应后，首先会检查响应状态码。如果状态码是 200 OK 等表示成功的状态码，浏览器会根据响应头中的内容类型信息来处理响应体。如果内容类型是 text/html，浏览器会开始解析 HTML 代码，构建 DOM 树，在解析 HTML 的过程中，遇到外部资源引用（如&#39;&lt;&#39;link&gt;标签引用 CSS 文件，&#39;&lt;&#39;script&gt;标签引用 JavaScript 文件，&#39;&lt;&#39;img&gt;标签引用图片等），浏览器会暂停 HTML 解析，发起新的请求来获取这些外部资源，然后继续解析。如果类型是 image/jpeg 等图片类型，浏览器会对图片数据进行解密并显示。如果是 application/json 等数据类型，浏览器可能会将数据传递给 JS 代码进行进一步处理。</li><li>在浏览器构建好 DOM 树，并且获取并处理好所有外部资源（如 CSS 文件、JavaScript 文件等）后，就会开始进行页面渲染。浏览器会根据 DOM 树和 CSS 样式规则构建渲染树。渲染树包含了页面中所有可见元素的样式和布局信息。然后，浏览器会根据渲染树进行布局，确定每个元素在页面中的位置和大小，并最终将页面内容绘制到屏幕上。在这个过程中，JavaScript 代码可能会对 DOM 树和页面布局进行动态修改，导致浏览器重新进行渲染和绘制。例如，通过 JS 修改了一个元素的样式或者添加了新的元素，浏览器会重新计算渲染树、重新布局和绘制，以更新页面显示。</li></ol>`,61)])])}const E=s(t,[["render",n]]);export{c as __pageData,E as default};
